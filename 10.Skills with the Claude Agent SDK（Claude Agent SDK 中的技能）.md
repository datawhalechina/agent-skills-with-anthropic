

### 第十课：Skills with the Claude Agent SDK（Claude Agent SDK 中的技能）
本节课我们将脱离网页版 Claude 和命令行界面，深入讲解如何使用 **Claude Agent SDK** 以编程方式构建复杂的智能体应用。我们将从零开始构建一个 **通用研究智能体（Research Agent）**，它能够利用技能（Skills）规划任务，调度多个子智能体（Sub-agents）并行协作，并利用 MCP 将最终成果写入外部系统（Notion）。

--------------------------------------------------------------------------------

#### 1、系统架构：指挥官与专家团队 (The Architecture)
在 SDK 中构建的系统模仿了一个高效的工程团队结构。SDK 充当了底层的“脚手架” (Harness)，支撑起以下组件的协同工作：

*   **Main Agent (Orchestrator)**：作为指挥官，负责理解用户需求，加载技能来制定研究方法，并通过任务工具调度子智能体。
*   **Sub-agents (Specialists)**：三个专门的子智能体，拥有各自独立的上下文窗口和工具集，负责具体执行。
*   **Skill (Process)**：定义了“如何学习一个新工具”的标准流程，仅供主智能体使用。
*   **MCP (External Action)**：连接 Notion，用于最终成果的文档化。

--------------------------------------------------------------------------------

#### 2、角色分工与工具配置 (Roles & Tools Configuration)

在 `agent.py` 代码中，我们显式定义了不同角色的能力边界。

| 角色 (Role) | 名称 (Name) | 核心职责 (Responsibilities) | 关键工具配置 (Key Tools) |
| :--- | :--- | :--- | :--- |
| **主智能体** | Main Agent | **编排与合成**。加载技能制定计划，分派任务给子智能体，汇总结果并写入 Notion。 | `TaskTool` (分派任务), `SkillTool` (加载技能), `mcp_notion_*` |
| **子智能体 1** | Docs Researcher | **文档研究**。查找和阅读官方文档，提取关键信息。 | `WebSearch`, `WebFetch` |
| **子智能体 2** | Repo Analyzer | **代码分析**。克隆 GitHub 仓库，分析文件结构和代码逻辑。 | **`Bash`** (执行 git clone), `Read`, `Grep`, `WebSearch` |
| **子智能体 3** | Web Researcher | **广泛搜索**。查找教程、视频（YouTube）和社区讨论。 | `WebSearch`, `WebFetch` |

--------------------------------------------------------------------------------

#### 3、代码实现核心步骤 (Code Implementation Anatomy)

构建 `agent.py` 的过程展示了 SDK 的核心用法：

##### A. 初始化与依赖 (Setup)
*   **环境准备**：运行 `uv init` 初始化项目，并安装关键库：`claude-agent-sdk`, `python-dotenv`, `asyncio`。
*   **辅助功能**：引入 `display_message`，用于在终端中美观地打印智能体的思考过程（Thinking process）和工具调用结果。

##### B. 权限与工具 (Permissions & Tools)
SDK 默认是安全的（只读）。为了赋予智能体实际行动力，必须在 `allowed_tools` 列表中显式添加高权限工具：
*   **`Bash`**：允许执行 Shell 命令（如 `git clone`）。
*   **`Write`**：允许创建和写入文件（如生成 `README.md`）。
*   **`WebSearch` & `WebFetch`**：允许联网获取信息。

##### C. 技能集成 (Skill Tool)
为了让主智能体能够读取和使用技能文件，必须配置 **Skill Tool**：
*   **工具加载**：添加 `SkillTool` 到工具列表。
*   **路径指定**：通过 `setting_sources` 参数指定技能文件的存储位置（例如 `project` 目录下的 `.claude/skills`），确保 SDK 能找到 `SKILL.md`。

##### D. 子智能体定义 (Defining Sub-agents)
*   使用 `AgentDefinition` 类定义子智能体。
*   **关键点**：每个子智能体都有自己独立的 `system_prompt`（通常加载自 Markdown 文件）和特定的工具集。例如，只有 `Repo Analyzer` 需要 `Bash` 权限，其他研究员不需要。

##### E. MCP 连接 (Connecting Notion)
*   **服务器配置**：通过 `mcp_servers` 参数定义 Notion MCP 的启动命令和环境变量（Token）。
*   **工具白名单**：必须将 Notion 的工具（如 `mcp_notion_append_block_children`）添加到主智能体的 `allowed_tools` 中，使其有权操作 Notion 页面。

--------------------------------------------------------------------------------

#### 4、工作流演示：研究 "MinerU" (Execution Flow)

课程演示了从零开始研究开源工具 "MinerU"（PDF 提取工具）的完整生命周期：

| 阶段 | 动作描述 | 涉及技术组件 |
| :--- | :--- | :--- |
| **1. 规划 (Plan)** | 用户提问，主智能体加载 `learning-a-tool` 技能。技能通过**渐进式披露**加载 `progressive_learning.md`，生成详细的研究计划。 | **Skill Tool** |
| **2. 并行执行 (Parallel Execution)** | 主智能体根据计划，使用 `Task` 工具**同时调度**三个子智能体。Docs Researcher 查文档，Repo Analyzer 克隆代码，Web Researcher 搜视频。 | **Task Tool & Sub-agents** |
| **3. 合成 (Synthesize)** | 子智能体完成任务后，主智能体汇总信息，在本地文件系统生成标准化的目录结构：`README.md`（含学习路径）、`resources.md` 和 `examples/`。 | **Main Agent Context** |
| **4. 交付 (Deliver)** | 用户请求将资源同步到云端。主智能体调用 Notion MCP 工具，读取本地 `resources.md` 并将其转换为 Notion 富文本块写入指定页面。 | **MCP (Notion)** |

--------------------------------------------------------------------------------

#### 5、关键概念与最佳实践 (Key Takeaways)

*   **技能的定位 (Purpose of Skills)**：
    在本案例中，技能 (`learning-a-tool`) **不是给子智能体用的**，而是专门给 **主智能体 (Orchestrator)** 用的。它作为“指导手册”，为非确定性的 AI 模型提供了一个**可预测的工作流**（即：先做计划，再并行研究，最后按特定格式输出）。

*   **渐进式披露 (Progressive Disclosure)**：
    为了保护上下文窗口，技能文件最初只加载名称和描述。只有当技能被实际触发时，才会加载底层的 `SKILL.md`。而在该技能内部，它进一步引用了 `progressive_learning.md`，这种分层加载机制确保了 Token 的高效利用。

*   **SDK vs Claude Code**：
    *   **Claude Code** 是一个交互式的命令行工具 (CLI)。
    *   **Agent SDK** 是一个编程框架。它允许开发者通过代码精细控制智能体的每一个环节（如系统提示词、允许的工具集、错误处理逻辑），适合构建定制化的应用程序。

*   **安全性 (Security Note)**：
    演示代码中为了方便，直接允许了 `Bash` 和 `Write` 的自动执行。在生产环境中，应该建立 **"Human-in-the-loop" (人机回环)** 机制，对于涉及文件修改、命令执行或 API 写入（如 Notion）的操作，必须在执行前寻求用户的明确确认。